# Linux 相关
## 什么是Linux?
Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
## Unix和Linux有什么区别？
Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区别。
1.  开源性
Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。
2.  跨平台性
Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。
3.  可视化界面
Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。
4.  硬件环境
Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，安装难度较大。
5. 用户群体
Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。<br>
相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用！
## 什么是 Linux 内核？
Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。
1、系统内存管理
2、应用程序管理
3、硬件设备管理
4、文件系统管理
## Linux的基本组件是什么？
就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。
## Linux 的体系结构?

1. 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。
2. 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code)
## Linux 开机启动过程？
> 了解即可。

1、主机加电自检，加载 BIOS 硬件信息。
2、读取 MBR 的引导文件(GRUB、LILO)。
3、引导 Linux 内核。
4、运行第一个进程 init (进程号永远为 1 )。
5、进入相应的运行级别。
6、运行终端，输入用户名和密码。
## Linux系统缺省的运行级别？

- 关机。
- 单机用户模式。
- 字符界面的多用户模式(不支持网络)。
- 字符界面的多用户模式。
- 未分配使用。
- 图形界面的多用户模式。
- 重启。
## Linux 有哪些系统日志文件？
比较重要的是` /var/log/messages` 日志文件。
> 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。
另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。

## Linux系统安装多个桌面环境有帮助吗？
通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。
## 什么是交换空间？
交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。
## 什么是root帐户?
root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。
## 什么是LILO？
LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。
## 什么是CLI？
命令行界面（英语**：command-line interface**，缩写]：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）。
通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。
## 什么是GUI？
图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。
图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。
## 开源的优势是什么？
开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。
## 简单 Linux 文件系统？
在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。
也就是说在 Linux 系统中有一个重要的概念：一切都是文件。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。

1. 普通文件：包含 程序源代码，视频图片等
2. 目录文件：用于表示和管理系统中的文件，目录文化中包含一些文件名和子目录名
3. 链接文件：用于不同目录下文件的共享
4. 设备文件：用来访问硬件设备
5. 命名管道：特殊的文件类型，用于进程之间通信
## Linux 的目录结构是怎样的？

- /bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；
- /etc： 存放系统管理和配置文件；
- /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；
- /usr： 用于存放系统应用程序；
- /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；
- /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；
- /root： 超级用户（系统管理员）的主目录（特权阶级o）；
- /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；
- /dev： 用于存放设备文件；
- /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
- /boot： 存放用于系统引导时使用的各种文件；
- /lib： 存放着和系统运行相关的库文件 ；
- /tmp： 用于存放各种临时文件，是公用的临时文件存储点；
- /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；
- /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。
## 什么是 inode ？
> 一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬盘储存的基础。

理解inode，要从文件储存说起。
文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。
文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。
每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。
## 简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？
> 如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。

Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。

- inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。
- Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。
## 什么是硬链接和软链接？
1）硬链接
由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。

- 不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。

2）软链接
软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。

- 不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。

实际场景下，基本是使用软链接。总结区别如下：

- 硬链接不可以跨分区，软件链可以跨分区。
- 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。
- 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。
## RAID 是什么?
RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。
RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。
## Linux 系统安全相关
### 一台 Linux 系统初始化环境后需要做一些什么安全工作？

- 1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。
> 修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。

- 2、服务器使用密钥登陆，禁止密码登陆。
- 3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。
- 4、装 fail2ban 这种防止 SSH 暴力破击的软件。
- 5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)
> 也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。

- 6、修改历史命令记录的条数为 10 条。
- 7、只允许有需要的服务器可以访问外网，其它全部禁止。
- 8、做好软件层面的防护。
   - 8.1 设置 nginx_waf 模块防止 SQL 注入。
   - 8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。
### 什么叫 CC 攻击？什么叫 DDOS 攻击？
CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。
DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。
> 攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。

### 怎么预防 CC 攻击和 DDOS 攻击？
防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。
> 流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。

### 什么是网站数据库注入？
由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。
应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。
SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。
### 如何过滤与预防？
数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。
## 通过伙伴系统申请内核内存的函数有哪些?
在物理页面管理上实现了基于区的伙伴系统(zone based buddy system)。对不同区的内存 使用单独的伙伴系统(buddy system)管理,而且独立地监控空闲页。
相应接口`alloc_pages(gfp_mask, order)`,`_ _get_free_pages(gfp_mask, order)`等。
## Linux 虚拟文件系统的关键数据结构有哪些?(至少写出四个)

- struct super_block
- struct inode
- struct fil
- struct dentry
## 对文件或设备的操作函数保存在那个数据结构中?
struct file_operations
## 如何加载、卸载一个模块?

- insmod 加载
- rmmod 卸载
## 模块和应用程序分别运行在什么空间?
模块运行在内核空间,应用程序运行在用户空间
## Linux 中的浮点运算由应用程序实现还是内核实现?
应用程序实现,Linux 中的浮点运算是利用数学库函数实现的,库函数能够被应用程序链接后 调用,不能被内核链接调用。这些运算是在应用程序中运行的,然后再把结果反馈给系统。 Linux 内核如果一定要进行浮点运算,需要在建立内核时选上 math-emu,使用软件模拟计算 浮点运算,据说这样做的代价有两个:用户在安装驱动时需要重建内核,可能会影响到其他的 应用程序,使得这些应用程序在做浮点运算的时候也使用 math-emu,大大的降低了效率。
## 模块程序能否使用可链接的库函数?
模块程序运行在内核空间,不能链接库函数。
## TLB 中缓存的是什么内容?
TLB,页表缓存,当线性地址被第一次转换成物理地址的时候,将线性地址和物理地址的对应 放到 TLB 中,用于下次访问这个线性地址时,加快转换速度。
## Linux 中有哪几种设备?
字符设备和块设备。网卡是例外,他不直接与设备文件对应,mknod 系统调用用来创建设备 文件。
## 字符设备驱动程序的关键数据结构是哪个?
字符设备描述符 struct cdev,cdev_alloc()用于动态的分配 cdev 描述符,cdev_add()用于注 册一个 cdev 描述符,cdev 包含一个 struct kobject 类型的数据结构它是核心的数据结构
设备驱动程序包括哪些功能函数?

- open()
- read()
- write()
- llseek()
- realse()
## 如何唯一标识一个设备?
Linux 使用一个设备编号来唯一的标示一个设备,设备编号分为:主设备号和次设备号,一般主 设备号标示设备对应的驱动程序,次设备号对应设备文件指向的设备,在内核中使用 dev_t 来 表示设备编号,一般它是 32 位长度,其中 12 位用于表示主设备号,20 位用于表示次设备号, 利用 MKDEV(int major,int minor);用于生成一个 dev_t 类型的对象。
## Linux 通过什么方式实现系统调用?
靠软件中断实现的,首先,用户程序为系统调用设置参数,其中一个编号是系统调用编号,参数 设置完成后,程序执行系统调用指令,x86 上的软中断是有 int 产生的,这个指令会导致一个异 常,产生一个事件,这个事件会导致处理器跳转到内核态并跳转到一个新的地址。并开始处 理那里的异常处理程序,此时的异常处理就是系统调用程序。
## Linux 软中断和工作队列的作用是什么?
Linux 中的软中断和工作队列是中断处理。
1.软中断一般是“可延迟函数”的总称,它不能睡眠,不能阻塞,它处于中断上下文,不能进城切 换,软中断不能被自己打断,只能被硬件中断打断(上半部),可以并发的运行在多个 CPU 上。 所以软中断必须设计成可重入的函数,因此也需要自旋锁来保护其数据结构。
2.工作队列中的函数处在进程上下文中,它可以睡眠,也能被阻塞,能够在不同的进程间切 换。已完成不同的工作。 可延迟函数和工作队列都不能访问用户的进程空间,可延时函数在执行时不可能有任何正在 运行的进程,工作队列的函数有内核进程执行,他不能访问用户空间地址
## Linux开机启动过程？
1）主机加电自检，加载BOLS硬件信息
2）读取MBR的引导文件（grub，lilo）
3）引导linux内核
4）运行第一个进程init（进程号永远为1）
5）进入相应的运行级别
6）运行终端，输入用户名和密码
## 详细说明keepalived的故障切换工作原理
这种故障切换是通过VRRP协议来实现的，主节点会按一定的时间间隔发送心跳信息的广播包，告诉备节点自己的存活状态信息，当主节点发生故障时，备节点在一段时间内就收到广播包，从而判断主节点出现故障，因此会调用自身的接管程序来接管主节点的IP资源及服务，当主节点恢复时，备节点会主动释放资源，恢复到接管前的状态，从而来实现主备故障切换
## 什么是系统调用？
根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：
用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。
说了用户态和系统态之后，那么什么是系统调用呢？
运行的应用程序基本都是运行在用户态，如果调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！
也就是说在运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。
## 操作系统的内存管理主要是做什么？
操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。
## 常见的几种内存管理机制
简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。
块式管理 ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，称之为碎片。
页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
## 快表和多级页表
在分页内存管理中，很重要的两点是：
虚拟地址到物理地址的转换要快。
解决虚拟地址空间大，页表也会很大的问题。
### 快表
为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。
使用快表之后的地址转换流程是这样的：
根据虚拟地址中的页号查快表；
如果该页在快表中，直接从快表中读取相应的物理地址；
如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。
看完了之后会发现快表和平时经常在开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，都可以在日常开发使用的各种工具或者框架中找到它们的影子。
### 多级页表
引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。
## 分页机制和分段机制的共同点和区别
共同点：
分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。
区别：
页的大小是固定的，由操作系统决定；而段的大小不固定，取决于当前运行的程序。
分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。
## 逻辑(虚拟)地址和物理地址
逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。
## CPU 寻址了解吗?为什么需要虚拟地址空间?
现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。
## 什么是虚拟内存(Virtual Memory)?
虚拟内存是计算机系统内存管理的一种技术，可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
## 局部性原理
局部性原理表现在以下两个方面：
时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。
时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。
## 虚拟存储器
基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。
实际上，虚拟内存同样是一种时间换空间的策略，用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。程序世界几乎不是时间换空间就是空间换时间。
## 虚拟内存的技术实现
虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：
请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
请求段页式存储管理
不管是上面那种实现方式，一般都需要：
一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；
虚拟地址空间 ：逻辑地址到物理地址的变换。
# Linux 命令相关
## 查看系统当前进程连接数？
```bash
netstat -an | grep ESTABLISHED | wc -l
```
## 如何在/usr目录下找出大小超过10MB的文件?
```bash
find /usr -size +10M
```
## 添加一条到192.168.3.0/24的路由，网关为192.168.1.254？
```bash
route add -net 192.168.3.0/24 netmask 255.255.255.0 gw 192.168.1.254
```
## 如何在/var目录下找出90天之内未被访问过的文件?
```bash
find /var \! -atime -90
```
## 如何在/home目录下找出120天之前被修改过的文件?
```bash
find /home  -mtime +120
```
## 在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。
```bash
find / -name core -exec rm {} \;
```
## 有一普通用户想在每周日凌晨零点零分定期备份/user/backup到/tmp目录下，该用户应如何做?
```bash
crontab -e
0 0 * * 7 /bin/cp /user/backup /tmp
```
## 每周一下午三点将/tmp/logs目录下面的后缀为*.log的所有文件rsync同步到备份服务器192.168.1.100中同样的目录下面，crontab配置项该如何写？
```bash
00 15 * * 1 rsync -avzP /tmp/logs/*.log root@192.168.1.100:/tmp/logs
```
## 找到/tmp/目录下面的所有名称以"_s1.jpg"结尾的普通文件，如果其修改日期在一天内，则将其打包到/tmp/back.tar.gz文件中
```bash
find /tmp -type f -name ".*_sj.jpg" -mtime 1|xarges tar zxf /tmp/back.tar.gz
```
## 配置mysql服务器的时候，配置了auto_increment_increment=3，请问这里的3意味着什么？
```bash
auto_increment是用于主键自动增长的，从3开始增长，3表示自增的起始值
```
## Linux 命令实操相关
### 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？
绝对路径： 如/etc/init.d
当前目录和上层目录： ./  ../
主目录： ~/
切换目录： cd
### 怎么查看当前进程？怎么执行退出？怎么查看当前路径？
查看当前进程： ps
执行退出： exit
查看当前路径： pwd
### 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户
清屏： clear
退出当前命令： ctrl+c 彻底退出
执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名
### 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？
绝对路径： 如/etc/init.d
当前目录和上层目录： ./  ../
主目录： ~/
切换目录： cd
### 怎么查看当前进程？怎么执行退出？怎么查看当前路径？
查看当前进程： ps
执行退出： exit
查看当前路径： pwd
### 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？
清屏： clear
退出当前命令： ctrl+c 彻底退出
执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名
查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告诉你一些常用参数； info adduesr；
### Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？
ls 执行的功能： 列出指定目录中的目录，以及文件
哪些参数以及区别： a 所有文件l 详细信息，包括大小字节数，可读可写可执行的权限等
### 建立软链接(快捷方式)，以及硬链接的命令。
软链接： ln -s slink source
硬链接： ln link source
### 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？
创建目录： mkdir
创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件
复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？
文件权限修改： chmod
格式如下：

```
chmodu+xfile给file的属主增加执行权限 chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
chmodu=rwx,g=rx,o=xfile上例的另一种形式 chmod =r file 为所有用户分配读权限
chmod444file同上例 chmod a-wx,a+r file同上例
$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限
```
### 使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？
使用命令repquota 能够显示出一个文件系统的配额信息
### 查看文件内容有哪些命令可以使用？
vi 文件名 #编辑方式查看，可修改
cat 文件名 #显示全部文件内容
more 文件名 #分页显示文件内容
less 文件名 #与 more 相似，更好的是可以往前翻页
tail 文件名 #仅查看尾部，还可以指定行数
head 文件名 #仅查看头部,还可以指定行数
### 随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”? 
写文件命令：vi
向屏幕输出带空格的字符串:`echo hello world`
### 终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？
终端  /dev/tty
黑洞文件  /dev/null
### 移动文件用哪个命令？改名用哪个命令？
```
mv mv
```
### 复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？
```
cp cp -r  ？？？？
```
### 删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？
```bash
rm rm -r rmdir
```
### Linux 下命令有哪几种可使用的通配符？分别代表什么含义?
“？”可替代单个字符。
“*”可替代任意多个字符。
方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]
### 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)
```bash
wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。
```
### Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?
是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。
grep [stringSTRING] filename grep [^string] filename
### Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？
（1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。
（2）、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。
（3）、就绪状态：在 run_queue 队列里的状态
（4）、运行状态：在 run_queue 队列里的状态
（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起
（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉
（7）、退出状态

```
D 不可中断 Uninterruptible（usually IO）
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核 2.6 开始无效）
X 死掉的进程
```
### 怎么使一个命令在后台运行?
一般都是使用 & 在命令结尾来让程序自动运行。(命令后可以不追加空格)
### 利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？
```
ps -ef (system v 输出) 

ps -aux bsd 格式输出

ps -ef | grep pid
```
### 哪个命令专门用来查看后台任务? 
`job -l`
### 把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?
把后台任务调到前台执行 fg
把停下的后台任务在后台执行起来 bg
### 终止进程用什么命令? 带什么参数? 
```
kill [-s <信息名称或编号>][程序] 或 kill [-l <信息编号>] 

kill-9 pid
```
### 怎么查看系统支持的所有信号？
`kill -l`
### 搜索文件用什么命令? 格式是怎么样的? 
```
find <指定目录> <指定条件> <指定动作>

whereis 加参数与文件名

locate 只加文件名

find 直接搜索磁盘，较慢。

find / -name "string*"
```
### 查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?
查找自己所在的终端信息：who am i
查看当前谁在使用该主机：who
### 使用什么命令查看用过的命令列表?
`history`
### 使用什么命令查看磁盘使用空间？ 空闲空间呢?
df -hl
文件系统 容量 已用 可用 已用% 挂载点
Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /
/dev/hda1 494M 19M 450M 4% /boot
### 使用什么命令查看网络是否连通?
`netstat`
### 使用什么命令查看 ip 地址及接口信息？
ifconfig
### 查看各类环境变量用什么命令?
查看所有 env
查看某个，如 home： env $HOME
### 通过什么命令指定命令提示符?
```
\u：显示当前用户账号

\h：显示当前主机名

\W：只显示当前路径最后一个目录

\w：显示当前绝对路径（当前用户目录会以~代替）

$PWD：显示当前全路径

$：显示命令行’$'或者’#'符号

\#：下达的第几个命令

\d：代表日期，格式为week day month date，例如："MonAug1"

\t：显示时间为24小时格式，如：HH：MM：SS

\T：显示时间为12小时格式

\A：显示时间为24小时格式：HH：MM

\v：BASH的版本信息 如export PS1=’[\u@\h\w\#]$‘
```
### 查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加? 
```
whereis [-bfmsu][-B <目录>...][-M <目录>...][-S <目录>...][文件...]
```
补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。
```
-b   只查找二进制文件。
-B<目录> 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。
-m   只查找说明文件。
-M<目录> 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。
-S<目录> 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。
which 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。
-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。
-V   显示版本信息
```
### 通过什么命令查找执行命令?
which 只能查可执行文件
whereis 只能查二进制文件、说明文档，源文件等
### 怎么对命令进行取别名？
alias la='ls -a'
### du 和 df 的定义，以及区别？
du 显示目录或文件的大小
df 显示每个<文件>所在的文件系统的信息，默认是显示所有文件系统。
（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。
df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。
### 当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？
可以使用bind命令，bind可以很方便地在shell中实现宏或按键的绑定。
在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。
比如获取F12的字符序列获取方法如下：先按下Ctrl+V,然后按下F12 .我们就可以得到F12的字符序列 ^[[24~。
接着使用bind进行绑定。
```
[root@localhost ~]# bind ‘”\e[24~":"date"'
```
注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。
【附】也可以使用showkey -a命令查看按键对应的字符序列。
### 如果一个linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？
使用命令compgen ­-c，可以打印出所有支持的命令列表。
```
[root@localhost ~]$ compgen -c

l.

ll

ls

which

if

then

else

elif

fi

case

esac

for

select

while

until

do

done

…
```
### 如果你的助手想要打印出当前的目录栈，你会建议他怎么做？
使用Linux 命令dirs可以将当前的目录栈打印出来。
```
[root@localhost ~]# dirs

/usr/share/X11
```
【附】：目录栈通过pushd popd 来操作。
### 你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？
使用linux命令 ’disown -r ’可以将所有正在运行的进程移除。
### bash shell 中的hash 命令有什么作用？
linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。
```
[root@localhost ~]# hash

hits command

2 /bin/ls

2 /bin/su
```
### 哪一个bash内置命令能够进行数学运算。
```
bash shell 的内置命令let 可以进行整型数的数学运算。

#! /bin/bash
…
…
let c=a+b
…
…
```
### 怎样一页一页地查看一个大文件的内容呢？
通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.
```
[root@localhost ~]# cat file_name.txt | more
```
### 数据字典属于哪一个用户的？
数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的
### 怎样查看一个linux命令的概要与用法？假设你在/bin目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？
使用命令whatis 可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat 去查看‘zcat’的介绍以及使用简要。
```
[root@localhost ~]# whatis zcat

zcat [gzip] (1) – compress or expand files
```
# Linux 进程与线程
## Linux 使用的进程间通信方式？

- 1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。
- 2、信号(signal) 。
- 3、消息队列。
- 4、共享内存。
- 5、信号量。
- 6、套接字(socket)
## 用户进程间通信主要哪几种方式?
(1)管道(Pipe):管道可用于具有亲缘关系进程间的通信,允许一个进程和另一个与它有共同祖 先的进程之间进行通信。
(2)命名管道(named pipe):命名管道克服了管道没有名字的限制,因此,除具有管道所具有的 功能外,它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名 管道通过命令 mkfifo 或系统调用 mkfifo 来创建。
(3)信号(Signal):信号是比较复杂的通信方式,用于通知接受进程有某种事件发生,除了用于进 程间通信外,进程还可以发送信号给进程本身;linux 除了支持 Unix 早期信号语义函数 sigal 外,还支持语义符合 Posix.1 标准的信号函数 sigaction(实际上,该函数是基于 BSD 的,BSD 为了实现可靠信号机制,又能够统一对外接口,用 sigaction 函数重新实现了 signal 函数)。
(4)消息(Message)队列:消息队列是消息的链接表,包括 Posix 消息队列 system V 消息队 列。有足够权限的进程可以向队列中添加消息,被赋予读权限的进程则可以读走队列中的消 息。消息队列克服了信号承载信息量少,管道只能承载无格式字节流以及缓冲区大小受限等 缺
(5)共享内存:使得多个进程可以访问同一块内存空间,是最快的可用 IPC 形式。是针对其他 通信机制运行效率较低而设计的。往往与其它通信机制,如信号量结合使用,来达到进程间 的同步及互斥。
(6)信号量(semaphore):主要作为进程间以及同一进程不同线程之间的同步手段。
(7)套接字(Socket):更为一般的进程间通信机制,可用于不同机器之间的进程间通信。起初是 由 Unix 系统的 BSD 分支开发出来的,但现在一般可以移植到其它类 Unix 系统上:Linux 和 System V 的变种都支持套接字。
## 创建进程的系统调用有那些?

- clone()
- fork()
- fork()

系统调用服务例程:

- sys_clone
- sys_fork
- sys_vfork
## 调用 schedule()进行进程切换的方式有几种?
1.系统调用 do_fork();
2.定时中断 do_timer();
3.唤醒进程 wake_up_process
4.改变进程的调度策略 setscheduler();
5.系统调用礼让 sys_sched_yield();
## Linux 调度程序是根据进程的动态优先级还是静态优先级来调度进程的?
Liunx 调度程序是根据根据进程的动态优先级来调度进程的,但是动态优先级又是根据静态 优先级根据算法计算出来的,两者是两个相关联的值。因为高优先级的进程总是比低优先级
的进程先被调度,为防止多个高优先级的进程占用 CPU 资源,导致其他进程不能占有 CPU, 所以引用动态优先级概念
## 进程调度的核心数据结构是哪个?
struct runqueue
## 进程和线程的区别？
线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。
## 进程有哪几种状态?
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
## 线程间的同步的方式
线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：
互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
## 进程的调度算法
先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。
优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
## 多进程和多线程之间如何选择？

- 使用多进程的场景：弱相关的任务、需要拓展到多机分布的任务；
- 使用多线程的场景：需要频繁创建和销毁的任务(如Web服务器)、需要进行大量计算的任务、强相关的任务、需要拓展到多核分布的任务。
## 进程的组成部分有哪些？
进程通常由进程控制块和相应的地址空间组成；
Linux环境下，进程控制块主要包含：

- 进程标识符(即进程ID)；
- 进程的当前状态；
- 相应的进程控制信息；

地址空间又可以分为：

- 文本段：存放相应的程序代码；
- 用户数据段：存放相应的程序处理数据；
- 系统数据段：存放相应的程序运行环境。
## 进程的基本状态有哪些？
创建、就绪、执行、等待和终止。
## 进程的上下文可以分为哪几个部分？

- 用户级上下文：正文、数据、用户堆栈以及共享存储区；
- 寄存器上下文：通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
- 系统级上下文：进程控制块(task_struct)、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。
## 什么是进程切换/上下文切换？
进程切换即上下文切换，是指处理器从一个进程切换到另一个进程，内核在处理器上对于进程进行以下操作：

1. 挂起一个进程，将这个进程在处理器中的状态（即上下文）存储于内存中；
2. 在内存中检索下一个进程的上下文，并将其在CPU的寄存器中恢复；
3. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
## 什么是孤儿进程？什么是僵尸进程？僵尸进程有什么危害？如何解决？

- 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程，将被`init`进程（进程号为1）所收养，并由`init`进程对这些子进程完成状态收集工作；
- 僵尸进程：一个进程使用`fork`创建子进程，如果子进程退出，而父进程并未调用`wait`或`waitpid`来获取子进程的状态信息，子进程的进程描述符仍然保存在系统中，那么这种子进程将成为僵尸进程。僵尸进程的危害：在子进程退出的时候，内核释放该子进程所有的资源，但仍保留进程号、退出状态、运行时间等信息，直到父进程通过`wait`或`waitpid`对其进行释放；但如果父进程不对保留信息进行释放，进程号会一直被占用，然而系统所能使用的进程号是有限的，如果产生大量的僵尸进程，系统将因没有可用的进程号而导致系统不能产生新的进程。解决僵尸进程的方法：
   - 父进程通过`wait`和`waitpid`等函数等待子进程结束，但这样会导致父进程挂起；
   - 如果父进程很忙，那么可用`signal`函数为`SIGCHLD`安装`handler`，这样当子进程结束后，父进程会收到信号，在`handler`中调用`wait`回收；
   - 如果父进程不关心子进程何时结束，那么可以用`signal(SIGCHLD, SIG_IGN)`通知内核，这样当子进程结束后，内核会对其进行回收；
   - `fork`两次，父进程`fork`一个子进程后继续工作，子进程`fork`一个孙进程后退出，那么孙进程将被`init`接管，这样当子进程结束后，内核会对其进行回收
## 什么是临界区？进程进入临界区的调度原则是什么？
临界区是一段针对共享资源的保护代码，该保护代码在任意时刻只允许一个线程对共享资源访问。
线程进入临界区的调度原则是：

1. 如果有若干进程要求进入空闲的临界区，则每次只允许一个进程进入；
2. 任何时候，处于临界区内的进程不可多于一个；
3. 进入临界区的进程要在有限时间内退出，以便其他进程能及时进入临界区；
4. 如果进程不能进入临界区，则应让出CPU，避免进程出现忙等现象。
## 线程创建的方式有哪几种？

1. 使用初始函数创建线程；
2. 使用类对象创建线程；
3. 使用lambda匿名函数创建线程。
## 为什么需要使用线程池？

- 过于频繁地创建或销毁线程会带来大量系统开销，影响处理效率；
- 线程并发数量过多，抢占系统资源从而导致阻塞；
- 可以对线程进行一些简单的管理，如延时执行、定时循环执行。
## 哪些资源是线程共享的？哪些资源是线程私有的？

- 线程共享：进程代码段、进程的公有数据、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID；
- 线程私有：线程ID、寄存器里的值、栈、线程的私有数据、线程的优先级、信号屏蔽码、错误返回码。
## 多线程锁的种类有哪些？
互斥锁、递归锁、自旋锁、读写锁。
## 什么是死锁？死锁产生的原因是什么？死锁有哪些必要条件？
死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，则这些进程都将无法向前推进。
死锁产生的原因：系统资源竞争、线程运行推进顺序不当。
死锁的四个必要条件：

1. 互斥条件：在一段时间内某资源只能被一个进程使用，如果有其他进程请求该资源，则请求进程只能等待；
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源已被其他进程占用，此时请求进程被阻塞，对自己已有资源保持不放；
3. 不可剥夺条件：进程所获得的资源在未使用完毕时，不能被其他进程强行夺走，即只能由获得该资源的进程主动释放；
4. 循环等待条件：若干进程间形成首尾相接、循环等待资源的关系。
## 如何预防死锁？如何避免死锁？如何检测死锁？如何解除死锁？
预防死锁的方法：核心思想是破坏死锁的四个必要条件之一，即

- 破坏请求与保持条件：采用预先静态分配的方法，即进程在运行前一次申请完它所需要的全部资源，在未满足全部资源时不运行；但系统资源被严重浪费，且易导致“饥饿”状态；
- 破坏不可剥夺条件：当一个进程请求新的资源但未满足时，该进程必须释放已经保持的所有资源，以后需要时再重新申请；但反复地申请和释放资源会增加系统开销，降低系统吞吐量；
- 破坏循环等待条件：采用顺序资源分配法，即给系统中的资源编号，规定每个进程必须按照编号顺序申请资源；但限制了新类型设备的增加。

避免死锁的方法：

- 进程启动拒绝：如果一个进程的请求会导致死锁，则不执行该进程；
- 资源分配拒绝：又名银行家算法，如果一个进程增加的资源请求会导致死锁，则不允许分配。

检测死锁的方法：

- 为每个进程和每个资源制定唯一编号；
- 设定一张资源分配表，记录各进程与占用资源之间的对应关系；
- 设定一张进程等待表，记录各进程与申请资源之间的对应关系；
- 判断是否出现环路，是则引发死锁。

解除死锁的方法：

- 资源剥夺法：挂起某些死锁进程，并释放其所保持的资源，分配给其他死锁进程，但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态；
- 撤销进程法：强制撤销部分、甚至全部死锁进程，并释放其所保持的资源；撤销顺序可以按照进程优先级和撤销进程代价的高低来进行；
- 进程回退法：让某些死锁进行回退到足以回避死锁的地步，回退过程中自愿释放自愿，但要求系统保留进程历史信息，设置还原点。
## 如何使用单线程处理高并发？
在单线程模型中，采用多路复用I/O来提高单线程处理多个请求的能力，然后采用事件驱动模型，基于异步回调来处理事件。
# bash 和 shell 相关
## 什么是BASH？
BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。
## BASH和DOS之间的基本区别是什么？
BASH和DOS控制台之间的主要区别在于3个方面：

- BASH命令区分大小写，而DOS命令则不区分;
- 在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符
- DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例。
## Shell 脚本是什么？
一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。
## 可以在 Shell 脚本中使用哪些类型的变量？
在 Shell 脚本，我们可以使用两种类型的变量：
系统定义变量
> 系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 set 命令查看。

用户定义变量
> 用户变量由系统用户来生成和定义，变量的值可以通过命令 "echo $<变量名>" 查看。

## shell 语法相关
### Shell 脚本中 if 语法如何嵌套?
```bash
if [ 条件 ]
then
命令1
命令2
…..
else
if [ 条件 ]
then
命令1
命令2
….
else
命令1
命令2
…..
fi
fi
```
### Shell 脚本中 case 语句的语法?
```bash
case 变量 in
值1)
命令1
命令2
…..
最后命令
!!
值2)
命令1
命令2
……
最后命令
;;
esac
```
### Shell 脚本中 for 循环语法？
```bash
for 变量 in 循环列表
do
命令1
命令2
….
最后命令
done
```
### Shell 脚本中 while 循环语法？
如同 for 循环，while 循环只要条件成立就重复它的命令块
不同于 for循环，while 循环会不断迭代，直到它的条件不为真。
```bash
while [ 条件 ]
do
命令…
done
```
### 如何使脚本可执行?
使用 chmod 命令来使脚本可执行。例子如下：`chmod a+x myscript.sh`
### 在 Shell 脚本如何定义函数呢？
函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：
```bash
$ diskusage () { df -h ; }
译注：下面是我给的shell函数语法，原文没有
[ function ] 函数名 [()]
{
命令;
[return int;]
}
```
### 判断一文件是不是字符设备文件，如果是将其拷贝到 /dev 目录下？
```bash
#!/bin/bash
read -p "Input file name: " FILENAME
if [ -c "$FILENAME" ];then
　　cp $FILENAME /dev
fi
```
### 添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？
```bash
#!/bin/bash
groupadd class1
for((i=1;i<31;i++))
do
        if [ $i -le 10 ];then
                useradd -g class1 std0$i
        else
                useradd -g class1 std$i
        fi
done
```

