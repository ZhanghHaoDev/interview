# 关键字相关
## static和const的使用

1. static:静态变量声明，分为局部静态变量，全局静态变量，类静态成员变量。也可修饰类成员函数。有以下几类：
**局部静态变量：**存储在静态存储区，程序运行期间只被初始化一次，作用域仍然为局部作用域，在变量定义的函数或语句块中有效，程序结束时由操作系统回收资源。
**全局静态变量：**存储在静态存储区，静态存储区中的资源在程序运行期间会一直存在，直到程序结束由系统回收。未初始化的变量会默认为0，作用域在声明他的文件中有效。
**类静态成员变量**：被类的所有对象共享，包括子对象。必须在类外初始化，不可以在构造函数内进行初始化。
类静态成员函数：所有对象共享该函数，不含this指针，不可使用类中非静态成员。
2. const：常量声明，类常成员函数声明。 const和static不可同时修饰类成员函数，const修饰成员函数表示不能修改对象的状态，static修饰成员函数表示该函数属于类，不属于对象，二者相互矛盾。const修饰变量时表示变量不可修改，修饰成员函数表示不可修改任意成员变量。
## 常用数据结构

1. vector：向量，连续存储，可随机访问。
2. deque：双向队列，连续存储，随机访问。
3. list：链表，内存不连续，不支持随机访问。
4. stack：栈，不可随机访问，只允许再开头增加/删除元素。
5. queue：单向队列，尾部增加，开头删除。
6. set：集合，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
7. map：图，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
8. hash_set：哈希表，随机访问。查找、插入、删除时间复杂读为O(1)。
## const与#define有什么区别

1. const和#define都可以定义常量，但是const用途更广。
2. const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
3. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。
## struct和class有什么区别？
C++中，class与struct都可以定义一个类。他们有以下两点区别：

1. 默认继承权限，如果不指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理
2. 成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
以上两点也是struct和class最基本的差别，也是最本质的差别；
3. 但是在C++中，struct进行了扩展，现在它已经不仅仅是一个包含不同数据类型的数据结构了，它包括了更多的功能。
4. Struct能包含成员函数、有自己的构造函数、可以有析构函数、支持继承、支持多态、支持Private、Protected、Public关键字。
5. 如果是class的父类是struct关键字描述的，那么默认访问属性是什么？
6. 当出现这种情况时，到底默认是public继承还是private继承，取决于子类而不是基类。
7. class可以继承自struct修饰的类；同时，struct也可以继承自class修饰的类，继承属性如下列描述：
```cpp
class A{};
class B:A{}; // private 继承
struct B:A{}; // public 继承
```
最后，那么到底是使用struct，还是使用class呢？
一般来说，两个关键字都是可以的，但是由于编程规范的问题，如果要定义的是一种数据结构，那么用struct，如果是一种对象的话，那么用class。
## 什么情况下，delete需要加一个中括号[]
当要删除的变量是一个数组时，delete需要加一个中括号[ ]，例如：delete array[0];
## sizeof/strlen区别？ C语言中malloc和C+ +语言中new有何区别？ C/C++ 程序编译的内存分配情况？
**sizeof和strlen的区别：**
sizeof是一个操作符，可以用来获取一个变量或类型的字节数，不受变量值的影响。例如，sizeof(int)返回4，sizeof(char)返回1。
strlen是一个函数，用于获取一个字符串的长度，即字符数组中的字符个数，不包括字符串结束符'\0'。例如，strlen("hello")返回5。
**malloc和new的区别：**
malloc和new都是用于在堆上分配内存的函数。它们的主要区别在于以下几点：
malloc返回一个void*指针，需要强制转换为目标类型指针，而new直接返回目标类型指针。
malloc只负责分配内存，不会自动调用构造函数，而new在分配内存后会自动调用构造函数。
malloc分配的内存可以使用free函数释放，而new分配的内存必须使用delete操作符释放。
**C/C++程序编译的内存分配情况：**
在C/C++程序编译时，内存分配主要分为以下几种情况：
栈内存分配：用于存储局部变量和函数调用的参数和返回值。栈内存分配由编译器自动完成，不需要手动分配和释放。
堆内存分配：用于存储动态分配的内存，需要使用malloc或new函数手动分配，并在不需要时使用free或delete操作符释放。
全局变量和静态变量分配：在程序运行前就进行内存分配，存储在静态存储区或全局存储区，程序结束后才会释放。
## strcpy/sprintf/memcpy它们之间区别？
strcpy、sprintf和memcpy都是C语言中的字符串和内存操作函数，它们之间的主要区别如下：

1. strcpy用于将一个字符串复制到另一个字符串中，比如将src字符串复制到dest字符串中。函数原型为：char *strcpy(char *dest, const char *src)；
2. sprintf用于将格式化的数据转换成字符串并存储到另一个字符串中，比如将格式化的数字或文本保存到buf字符串中。函数原型为：int sprintf(char *buf, const char *format, ...)；
memcpy用于将一段内存的内容复制到另一个内存中，比如将src内存的内容复制到dest内存中。函数原型为：void *memcpy(void *dest, const void *src, size_t n)；
3. 总的来说，这三个函数的作用不同，strcpy和memcpy主要用于字符串和内存的复制，而sprintf主要用于格式化数据的转换。使用时需要结合具体的需求选择合适的函数来操作。
## 常量相关
如何定义常量：使用关键字 const
常量的内存区域：局部常量存放在栈区，全局常量一般不分配内存，放在符号表当中提高访问效率
字面值常量放在常量区
## c++的强制转换

1. C风格的强制转换：简单但不安全，不推荐使用。
```cpp
int main() {
    double d = 3.14;
    int i = (int)d; // C风格的强制转换
    return 0;
}
```

2. `static_cast`：用于相关类型之间的转换，编译时进行类型检查。
```cpp
int main() {
    double d = 3.14;
    int i = static_cast<int>(d); // 使用static_cast进行转换
    return 0;
}
```

3. `dynamic_cast`：用于多态类型的转换，运行时进行类型检查。
```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void show() {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 使用dynamic_cast进行转换

    if (derivedPtr) {
        derivedPtr->show();
    } else {
        std::cout << "Conversion failed" << std::endl;
    }

    delete basePtr;
    return 0;
}
```

4. `const_cast`：用于去除或添加`const`属性。
```cpp
int main() {
    const int i = 42;
    int* p = const_cast<int*>(&i); // 使用const_cast去除const属性
    *p = 10;
    return 0;
}
```

5. `reinterpret_cast`：用于指针类型之间或指针与整数之间的转换，几乎不进行类型检查
```cpp
int main() {
    int i = 42;
    void* p = reinterpret_cast<void*>(&i); // 使用reinterpret_cast进行转换
    int* ip = reinterpret_cast<int*>(p);
    return 0;
}
```
## new，delete，malloc，free 的区别
new 和 delete 是操作符，malloc 和 free 是库函数
为什么有了 malloc 和 free 还需要 new 和 delete？
因为对于⾮内部数据类型⽽⾔，光⽤malloc／free ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于mallo，free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于malloc／free，所以有了new／delete 操作符。
# 指针相关
## 什么是智能指针，都有那些？
智能指针其作⽤是管理⼀个指针，避免咋们程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况滴发⽣。
然后使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。

1. `std::unique_ptr`是独占所有权的智能指针，确保同一时间只有一个指针可以拥有某块内存。

特点：独占所有权，不允许复制， 可以转移所有权（使用`std::move`）。
```cpp
#include <iostream>
#include <memory>

void uniquePtrExample() {
    std::unique_ptr<int> ptr1(new int(10)); // 创建一个unique_ptr
    std::cout << "ptr1: " << *ptr1 << std::endl;

    // std::unique_ptr<int> ptr2 = ptr1; // 错误：不能复制unique_ptr
    std::unique_ptr<int> ptr2 = std::move(ptr1); // 转移所有权
    std::cout << "ptr2: " << *ptr2 << std::endl;

    // ptr1现在为空
    if (!ptr1) {
        std::cout << "ptr1 is null" << std::endl;
    }
}

int main() {
    uniquePtrExample();
    return 0;
}
```

2. `std::shared_ptr`是共享所有权的智能指针，多个指针可以共享同一块内存，使用引用计数来管理内存。

特点：共享所有权，多个指针可以指向同一块内存。使用引用计数来管理内存，当引用计数为零时，自动释放内存。
```cpp
#include <iostream>
#include <memory>

void sharedPtrExample() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // 创建一个shared_ptr
    std::cout << "ptr1: " << *ptr1 << std::endl;

    std::shared_ptr<int> ptr2 = ptr1; // 共享所有权
    std::cout << "ptr2: " << *ptr2 << std::endl;

    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl; // 引用计数
    std::cout << "ptr2 use count: " << ptr2.use_count() << std::endl;
}

int main() {
    sharedPtrExample();
    return 0;
}
```

3. `std::weak_ptr`是一种不拥有所有权的智能指针，通常与`std::shared_ptr`配合使用，避免循环引用。

特点：不增加引用计数。需要通过`std::shared_ptr`来访问对象。
```cpp
#include <iostream>
#include <memory>

void weakPtrExample() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(30); // 创建一个shared_ptr
    std::weak_ptr<int> weakPtr = ptr1; // 创建一个weak_ptr

    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl; // 引用计数

    if (auto sharedPtr = weakPtr.lock()) { // 通过lock获取shared_ptr
        std::cout << "sharedPtr: " << *sharedPtr << std::endl;
    } else {
        std::cout << "weakPtr is expired" << std::endl;
    }
}

int main() {
    weakPtrExample();
    return 0;
}
```

4. 总结

`std::unique_ptr`：独占所有权，不能复制，只能转移所有权。
`std::shared_ptr`：共享所有权，使用引用计数管理内存。
`std::weak_ptr`：不拥有所有权，避免循环引用，需通过`lock`获取`std::shared_ptr`。
## 指针和引用有什么区别？什么情况下用指针，什么情况下用引用？
**区别：**

1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。
2. 有const指针，但是没有const引用。
3. 指针可以有多级，但是引用只能是一级（int** p；合法，而int&& a；不合法）。
4. 指针的值可以为空，但是引用的值不可以，并且引用在定义的时候必须初始化。
5. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在初始化后就不会再改变了，从一而终
6. sizeof引用得到的是所指向的变量（对象）的大小，而sizeof指针得到的是指针本身的大小。
7. 指针和引用的自增++运算意义不一样。

**相同点：**

1. 都可以对变量就行修改。
2. 都是地址的概念，指针指向一块内存，它的内容是所指内存的地址，引用是某块内存的别名。

**何时使用：**

1. 当考虑到存在不指向任何对象的可能，这时候应该使用指针。
2. 当需要在能够在不同的时刻指向不同的对象，这个时候使用指针。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么应该使用引用。
3. 当重载某个操作符时，应该使用引用。
## 野指针和悬空指针

1. 野指针是指那些未被初始化的指针。它们指向一个未知的内存地址，可能是随机的或未定义的。这种指针的使用会导致程序崩溃或其他未定义行为。
2. 悬空指针是指那些原本指向有效内存地址的指针，但该内存已经被释放或重新分配。使用悬空指针会导致访问无效的内存区域，可能引发程序崩溃或数据损坏。

**区别：**
野指针：指针未被初始化，指向一个未知或随机的内存地址。
悬空指针：指针原本指向有效内存，但该内存已经被释放或重新分配。
## 如何避免野指针
野指针是指指向无效内存地址的指针，它的出现往往会导致程序崩溃或者产生不可预期的结果。为了避免野指针的出现，可以采取以下措施：

1. 将指针初始化为NULL或nullptr，即空指针，可以防止指针误用。
2. 在指针被释放之后，将其赋值为NULL或nullptr，可以避免指针成为野指针。
3. 使用智能指针，智能指针可以自动管理动态内存，避免内存泄漏和野指针问题。
4. 避免指针操作过程中越界访问数组，可以使用STL容器代替数组，STL容器可以自动管理内存。
5. 对于指向栈上的变量的指针，需要注意其生命周期，避免在变量被销毁后仍然使用指针。
总之，在程序中使用指针时，需要时刻保持警惕，避免出现野指针问题。
## 函数指针

1. 定义：⾸先是定义：函数指针是指向函数的指针变 。函数指针本身⾸先是⼀个指针变 ，该指针变 指向⼀个具体的函数。这正如⽤指针变 可指向整型变 、字符型、数组⼀样，这⾥是指向函数。

在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变 后，可⽤该指针变 调⽤函数，就如同⽤指针变 可引⽤其他类型变 ⼀样，在这些概念上是⼤体⼀致的。

2. 用途：调⽤函数和做函数的参数，⽐如回调函数。
# 面向对象相关
## 谈一谈你对面向对象的理解
C++面向对象编程就是把一切事物都变成一个个对象，用属性和方法来描述对象的信息，比如定义一个猫对象，猫的眼睛、毛发、嘴巴就可以定义为猫对象的属性，猫的叫声和走路就可以定义为猫对象的方法。
用对象的方式编程，不仅方便了程序员，也使得代码的可复用性、可维护性变好。
C++面向对象的三大特性是封装、继承、多态。
## 面向对象的三大特征？ C+ +语言的空类有哪些成员函数？
**面向对象的三大特征是：**
封装：将数据和操作数据的函数封装在一个类中，隐藏了具体实现细节，只暴露必要的接口给外部使用，保证了数据的安全性和可靠性。
继承：通过继承已有的类，可以扩展其功能，减少代码的冗余，提高代码的复用性和可维护性。
多态：通过函数重载、虚函数和模板等机制，实现不同对象对同一消息的不同响应，提高了程序的灵活性和可扩展性。
C++语言的空类是指没有任何成员变量和成员函数的类。空类默认会自动生成一些成员函数，包括默认构造函数、析构函数、拷贝构造函数和赋值运算符等。如果需要控制这些默认生成的成员函数的行为，可以通过定义相应的函数来实现。
## 封装
### 参数传值、指针、引用有什么区别，在什么场景常用哪种传递方式？

1. 传值

这种传递方式中，实参和形参是两个不同的地址空间，参数传递的实质是将原函数中变量的值，复制到被调用函数形参所在的存储空间中，这个形参的地址空间在函数执行完毕后，会被回收掉。整个被调用函数对形参的操作，只影响形参对应的地址空间，不影响原来函数中的变量的值，因为这两个不是同一个存储空间。即使形参的值在函数中发生了变化，实参的值也完全不会受到影响，仍为调用前的值。

2. 传址

这种参数传递方式中，实参是变量的地址，形参是指针类型的变量，在函数中对指针变量的操作，就是对实参（变量地址）所对应的变量的操作，函数调用结束后，原函数中的变量的值将会发生改变。被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。

3. 传引用

这种参数传递方式中，形参是引用类型变量，其实就是实参的一个别名，在被调用函数中，对引用变量的所有操作等价于对实参的操作，这样，整个函数执行完毕后，原先的实参的值将会发生改变。被调函数对形参做的任何操作都影响了主调函数中的实参变量。

4. 哪一种更高效

在内置类型当中三种传递方式的效率上都差不多；
在自定义类型当中，传引用的更高效一些，因为它没有对形参进行一次拷贝
### c++当中重写和重定义的区别
**重写**是指在派生类中重新定义基类中已经存在的虚函数。重写的目的是为了在派生类中提供特定的实现，以取代基类中的实现。
**特点：**

1. 必须是虚函数（`virtual`）。
2. 函数签名（包括返回类型、函数名、参数列表）必须与基类中的虚函数完全相同。
3. 使用`override`关键字可以显式表明这是一个重写的函数（C++11及以上）。
```cpp
#include <iostream>

class Base {
public:
    virtual void display() const {
        std::cout << "Base display" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() const override { // 重写基类的虚函数
        std::cout << "Derived display" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->display(); // 调用的是Derived类的display函数
    delete basePtr;
    return 0;
}
```
**重定义**是指在派生类中重新定义基类中已经存在的非虚函数。重定义的目的是为了在派生类中提供新的实现，但不会影响基类的函数调用。
**特点**

1. 可以是非虚函数。
2. 函数签名可以与基类中的函数相同或不同。
3. 不会影响基类的函数调用。
```cpp
#include <iostream>

class Base {
public:
    void display() const {
        std::cout << "Base display" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() const { // 重定义基类的非虚函数
        std::cout << "Derived display" << std::endl;
    }
};

int main() {
    Base baseObj;
    Derived derivedObj;

    baseObj.display(); // 调用的是Base类的display函数
    derivedObj.display(); // 调用的是Derived类的display函数

    Base* basePtr = &derivedObj;
    basePtr->display(); // 调用的是Base类的display函数，因为它是非虚函数

    return 0;
}
```
**总结：**
重写（Override）：

1. 适用于虚函数。
2. 函数签名必须完全相同。
3. 通过基类指针或引用调用时，会调用派生类的实现。
4. 使用`override`关键字可以显式表明重写。

重定义（Redefine）：

1. 适用于非虚函数。
2. 函数签名可以相同或不同。
3. 通过基类指针或引用调用时，仍会调用基类的实现。
4. 不影响基类的函数调用。
### 介绍一些 c++的构造函数

1. 默认构造函数：无参数，用于默认初始化对象。
2. 参数化构造函数：带参数，用于初始化对象的成员变量。
3. 拷贝构造函数：通过复制现有对象来初始化新对象。
4. 移动构造函数：通过移动资源来初始化新对象，避免不必要的复制。
5. 委托构造函数：一个构造函数调用另一个构造函数，减少代码重复。
### 构造函数为什么⼀般不定义为虚函数

1. 虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体类型。但是，我们要创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；
2. ⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函数表来调⽤虚函数，那么这个调⽤实际上也是违反了先实例化后调⽤的准则。
### 析构函数
析构函数是一个没有参数，没有返回值，也不能重载，一个类当中只能有一个的函数
作用是：释放内存
### 析构函数⼀般写成虚函数的原因
直观的讲：是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数（该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏。
如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存。
### 构造函数或析构函数中调⽤虚函数会怎样
实际上是不应该在构造函数或析构函数中调⽤虚函数的，因为这样的调⽤其实并不会带来所想要的效果。
举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数action_type()
，在基类的构造函数中调⽤了这个虚函数。派⽣类中 写了这个虚函数，我们期望着根据对象的真实类型不同，⽽调⽤各⾃实现的虚函数，但实际上当我们创建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法。
也就是说构造派⽣类的基类部分是，编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实现，并没有按照我们想要的⽅式进⾏。即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象。
在析构函数中也是同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那么在执⾏基类的析构函数中是不可能调⽤到派⽣类 写的⽅法的。所以说，我们不应该在构在函数或析构函数中调⽤虚函数，就算调⽤⼀般也不会达到我们想要的结果。
## 继承
### 什么场景下使用继承方式，什么场景下使用组合？
**继承**：通过扩展已有的类来获得新功能的代码重用方法
**组合**：新类由现有类的对象合并而成的类的构造方式
**使用场景**：

1. 如果二者存在一个“是”的关系，并且一个类要对另外一个类公开所有接口，那么继承是更好的选择
2. 如果二者间存在一个“有”的关系，那么首选组合
3. 如果没有找到及其强烈无法辩驳的使用继承的的理由的时候，一律使用组合。组合体现为现实层面，继承主要体现在扩展方面。如果并不需要一个类的所有东西（包括接口和熟悉），那么就不需要使用继承，使用组合更好。如果使用继承，那么必须所有的都继承，如果有的东西你不需要继承但是你继承了，那么这就是滥用继承。
### 继承与派生的区别？
**角度不同**：继承是从子类的角度讲的，派生是从基类的角度讲的。
**定义不同：**派生指江河的源头产生出支流。引申为从一个主要事物的发展中分化出来。继承 是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等
### 单继承和多继承
单继承（派生类只从一个直接基类继承）时派生类的定义：class 派生类名：继承方式 基类名
多继承时派生类的定义：class 派生类名：继承方式1 基类名1，继承方式2 基类名2，…
注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承。
## 多态
### 如何理解多态

1. 定义：同一操作作用于不同的对象，产生不同的执行结果。C++多态意味着当调用虚成员函数时，会根据调用类型对象的实际类型执行不同的操作。
2. 实现：通过虚函数实现，用virtual声明的成员函数就是虚函数，允许子类重写。声明基类的指针或者引用指向不同的子类对象，调用相应的虚函数，可以根据指针或引用指向的子类的不同从而执行不同的操
3. Overload（重载）：函数名相同，参数类型或顺序不同的函数构成重载。
4. Override（重写）：派生类覆盖基类用virtual声明的成员函数。
5. Overwrite（隐藏）：派生类的函数屏蔽了与其同名的基类函数。派生类的函数与基类函数同名，但是参数不同，隐藏基类函数。如果参数相同，但是基类没有virtual关键字，基类函数将被隐藏。
### 多态实现的原理？链表和数组有何区别？队列和栈区别？
多态是面向对象编程中的一种重要概念，实现多态的关键是虚函数和指针。在C++中，通过将基类中的某个函数声明为虚函数，可以使得派生类中的同名函数成为虚函数，从而实现多态。当通过基类指针或引用调用虚函数时，会根据指针或引用实际指向的对象类型来调用相应的函数，实现了动态绑定。这样就可以在不同的对象之间实现相同的操作，提高了代码的复用性和可维护性。
**链表和数组的区别：**

1. 数组是一组具有相同数据类型的元素的集合，可以通过下标来访问每个元素，但是数组的长度是固定的，不能动态改变。
2. 链表是由一组节点构成的数据结构，每个节点包含数据和指向下一个节点的指针，可以动态添加、删除、修改节点，但是访问链表中的元素需要遍历整个链表，效率较低。

**队列和栈的区别：**

1. 队列是一种先进先出（FIFO）的数据结构，可以在队列的一端插入元素，在队列的另一端删除元素，典型的应用是操作系统的进程调度。
2. 栈是一种后进先出（LIFO）的数据结构，可以在栈顶插入和删除元素，典型的应用是函数调用和表达式求值。
### 纯虚函数（应⽤于接⼝继承和实现继承）
实际上，纯虚函数的出现就是为了让继承可以出现多种情况：

1. 有时我们希望派⽣类只继承成员函数的接⼝
2. 有时我们⼜希望派⽣类既继承成员函数的接⼝，⼜继承成员函数的实现，⽽且可以在派⽣类中可以 写成员函
3. 数以实现多态
4. 有的时候我们⼜希望派⽣类在继承成员函数接⼝和实现的情况下，不能 写缺省的实现。

其实，声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化。
对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调⽤这个实现的唯⼀⽅式是在派⽣类对象中指出其class 名称来调⽤。
### 虚函数表
 多态是由虚函数实现的，而虚函数主要是通过虚函数表实现的。如果一个类中包含虚函数，那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。该类的每个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），需指针指向虚函数表。注意：对象不包含虚函数表，只有需指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。 
### 什么情况下使用虚函数？和纯虚函数有什么区别？虚析构函数的作用是什么？（虚函数表）
虚函数的主要作用是“运行时多态”。虚析构函数的作用在于使用delete删除一个对象时，能确保析构函数被正确的执行。
区别：

1. 虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类(abstract class)，而只含有虚函数的类(class)不能被称为抽象类(abstract class)。
2. 虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类(sub class)中被重载，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类(abstract base class -ABC)之中，被继承的子类重载，目的是提供一个统一的接口
5. 虚函数的定义形式：virtual {method body}
纯虚函数的定义形式：virtual { } = 0;
在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。
6. 虚函数必须实现，如果不实现，编译器将报错，错误提示为：
   error LNK****: unresolved external symbol "public: virtual void __thiscall
   ClassName::virtualFunctionName(void)"
7. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
8. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
9. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
10. 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：译时多态性，运行时多态性。
编译时多态性：通过重载函数实现
 运行时多态性：通过虚函数实现。
11. 如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类(ABC)是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。
### 纯虚函数和普通的虚函数有什么区别

1. 纯虚函数是抽象类中的虚函数，它只有声明没有实现，它的实现由派生类完成，纯虚函数必须在派生类中实现。
2.  普通虚函数是普通类中的虚函数，它有声明也有实现，派生类可以重定义它，也可以不重定义它。
### 虚继承的作用
虚继承的作用是避免了多重继承时出现的二义性问题，即消除了基类的二义性，使得子类中只有一个完整的基类对象，从而避免了多重继承时出现的二义性问题。 
# 进程与线程
## 进程和线程的区别
进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。
**进程的定义：**一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、寄存器和程序变量的当前值。简单来说，进程就是一个程序的执行流程，内部保存程序运行所需的资源。在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停的在各个进程间游走，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。
** 线程的定义：**线程是进程当中的一条执行流程，这几乎就是进程的定义，一个进程内可以有多个子执行流程，即线程。从资源组合的角度看，进程把一组相关的资源组合起来，构成一个资源平台环境，包括地址空间（代码段，数据段），打开的文件等各种资源。从运行的角度看：进程是代码在这个资源平台上的执行流程，然而线程貌似也是这样，但是进程比线程多了资源内容列表样式：进程 = 线程 + 共享资源。
## 进程之间的通信方式有哪些？
管道，消息队列，共享内存，信号量，套接字，文件
## 知道死锁吗？死锁是如何产生的？

1. 死锁的产生有如下四个必要条件
2. 资源是互斥的,同一时刻只能有一个进程占有该资源
3. 资源的释放只能有该进程自己完成
4. 线程在获取到需要资源之前,不会释放已有资源
存在这么一条循环等待的队列,线程T1,T2,T3…, Tn

T1持有自己的资源请求T2的资源,….Tn持有自己的资源请求T1的资源
## 死锁怎么解决？

1. 避免死锁：可以采用一些技术避免死锁的发生，比如破坏互斥条件、破坏请求和保持条件、破坏循环等等。
2. 预防死锁：可以采用一些技术来预防死锁的发生，比如限制进程获取资源的数量、安全序列、死锁检测等等。
3. 解除死锁：可以采用一些技术来解除已经发生的死锁，比如银行家算法、延迟算法等等。
## C++多线程加锁，会劣化性能，请问有什么优化的手段

1. 合理设计程序：尽量减少加锁的次数，把多个操作放到一个加锁的代码段中，减少加锁的次数。
2. 使用原子操作：C++11提供了一些原子操作，比如atomic_compare_exchange_strong()等，可以用来替代锁，在某些场合可以有效提高性能。
3. 使用锁的粒度更小的技术：比如读写锁、条件变量等，可以替代普通的互斥锁，减少锁的粒度，提高性能。
4. 使用锁的粒度更大的技术：比如使用全局锁、细粒度锁等，可以减少锁的粒度，提高性能。
5. 使用非阻塞技术：比如CAS操作，可以避免线程之间的阻塞，从而提高性能。
# 编译相关
## 工作中有没有使用过动态库和静态库？能不能简单说下两者的区别？
**静态库**：在链接阶段将汇编生成的目标文件.o与引用库一起链接打包到可执行文件中，可简单看成（.o或者.obj文件的集合）。（1）对函数库的链接是放在编译时期完成的（2）程序在运行时与函数库没有瓜葛，移植方便（3）浪费空间和资源
**动态库：**（1）将库函数的链接载入推迟到程序运行时期（2）可以实现进程间的资源共享（因此也称为共享库）（3）将一些程序升级变得简单（4）可以真正的做到链接载入完全由程序员在程序代码中控制（显示调用）
动态库一般也会有个lib文件，那么和静态库lib文件有什么区别？
动态库中的.lib文件叫做导入库，对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。
静态库中的.lib叫做静态库，本身就包含了实际执行代码、符号表等等。
# 内存相关
## 一般什么情况下会出现内存泄漏？怎么用C++在编码层面尽量避免内存泄漏
内存泄漏是指程序向系统申请分配内存使用（new），用完以后却没有归还（delete）。结果申请的那块内存程序不再使用，而系统也无法再讲它分配给需要的程序。
**造成内存泄漏的几种情况：**

1. 指针重新赋值
2. 错误的内存释放
3. 返回值的不正确处理
4. new和delete没有配对使用。

**如何避免内存泄漏：**

1. 确保没有访问空指针。
2. 尽量使用智能指针。
3. new和delete配对使用。
## C++内存分配有几种方式
内存的三种分配方式

1. 从静态存储区分配：此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。
2. 在栈区分配：相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈内存分配运算内置于处理器的指令集中，效率高，但容量有限。
3. 在堆区分配：动态分配内存。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题。
## c++内存分区
c++内存分为下面几个区域：代码段，数据段，堆区，栈区，常量区
代码段：存储可执行的代码，通常是只读的
数据段：存储全局变量和静态变量
堆区：用于动态分配内存，程序员手动管理，需要手动申请和释放
栈区：用于存储局部变量和函数调用信息，编译器自动管理
常量区：存储常量数据，通常是只读的
## 结构体内存对⻬⽅式和为什么要进⾏内存对⻬？
# 其他语言相关
## c++和 c 语言的区别

1. c++有新增的关键字和语法，c++还允许我们定义自己的命名空间
2. 函数方面：c++支持重载函数，还支持虚函数，虚函数用来支持多态
3. c++新增了类 class 的概念，c 语言当中只有 struct 的概念，还添加了访问权限的概念，struct 的默认访问权限和继承权限都是 public，但是 class 的默认访问权限和默认继承权限都是 private
4. c++还添加了模板的概念和 STL 标准库
5. c 语言更看重面向对象，而 c++则是面对象的语言
## c++和 java 的区别

1. 垃圾回收：c++ 当中的内存都是程序员自己申请和释放的，java 则有自己的垃圾回收器
2. 语言特性：c++支持多重继承，而 java 只支持一个类继承多个接口。c++数据类型隐含转换机制，java 需要强制转换。
3. 数据类型和类：Java 当中取消了 c++的 struct 和 union 所有的成员都必须是类的一部分
# 实操题目

